#!/usr/bin/env python3
import os
import json
import glob
import sys
from parse_csl import parse_csl_test

# List of test files to include
TEST_FILES = [
    "disambiguate_YearSuffixAndSort.txt",
    "disambiguate_YearSuffixAtTwoLevels.txt",
    "disambiguate_YearSuffixMixedDates.txt",
    "disambiguate_ByCiteTwoAuthorsSameFamilyName.txt",
    "disambiguate_AddNamesSuccess.txt",
    "disambiguate_AddNamesFailure.txt",
    "disambiguate_ByCiteGivennameShortFormInitializeWith.txt",
    "disambiguate_BasedOnEtAlSubsequent.txt",
    "disambiguate_ByCiteDisambiguateCondition.txt",
    "disambiguate_FailWithYearSuffix.txt",
    "disambiguate_YearSuffixFiftyTwoEntries.txt",
]

# Helper function to find project root or adjust paths
# Assuming script is run from project root or its directory
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.dirname(SCRIPT_DIR))

# Use absolute paths to avoid confusion
BASE_DIR = os.path.join(PROJECT_ROOT, "tests/csl-test-suite/processor-tests/humans")

# Determine mode from CLI argument
MODE = "integration"  # default
if len(sys.argv) > 1 and sys.argv[1] == "--mode":
    if len(sys.argv) > 2:
        MODE = sys.argv[2]

if MODE == "processor":
    OUTPUT_FILE = os.path.join(
        PROJECT_ROOT,
        "crates/csln_processor/tests/disambiguation_native.rs"
    )
else:
    OUTPUT_FILE = os.path.join(
        PROJECT_ROOT,
        "crates/csln_processor/tests/disambiguation_csl.rs"
    )


def generate_rust_test_file():
    tests = []

    for filename in TEST_FILES:
        filepath = os.path.join(BASE_DIR, filename)
        if not os.path.exists(filepath):
            print(f"Warning: File not found: {filepath}")
            continue

        data = parse_csl_test(filepath)
        test_name = filename.replace(".txt", "").lower()

        # Escape raw string content for Rust
        # We use r####"..."#### to avoid escaping issues, assuming 4 hashes is enough
        csl = data.get("csl", "")

        # Sanitize input items: convert string years to integers for Rust csl_legacy compatibility
        raw_input_items = data.get("input_items", [])
        for item in raw_input_items:
             for date_field in ["issued", "accessed", "event-date", "original-date"]:
                 if date_field in item and "date-parts" in item[date_field]:
                     parts = item[date_field]["date-parts"]
                     new_parts = []
                     for date in parts:
                         new_date = []
                         for val in date:
                             if isinstance(val, str) and val.strip().lstrip("-").isdigit():
                                 new_date.append(int(val))
                             elif isinstance(val, int):
                                 new_date.append(val)
                             else:
                                 # Keep original if not an integer, but this will likely fail deserialization
                                 # if the target struct expects Vec<i32>.
                                 # We try to force 0 or skip if necessary?
                                 # Let's hope typical CSL tests only use strings for numbers or simple numbers.
                                 new_date.append(val)
                         new_parts.append(new_date)
                     item[date_field]["date-parts"] = new_parts

        input_items = json.dumps(raw_input_items, indent=None)

        # Citation Items usually come as [[{id:1}, {id:2}]] (list of citations, each with list of items)
        # We need to handle this.
        citation_items = json.dumps(data.get("citation_items", []), indent=None)

        result = data.get("result", "").strip()
        test_mode = data.get("mode", "citation").strip()

        tests.append({
            "name": test_name,
            "csl": csl,
            "input_items": input_items,
            "citation_items": citation_items,
            "result": result,
            "mode": test_mode
        })

    with open(OUTPUT_FILE, "w") as f:
        if MODE == "processor":
            f.write(RUST_HEADER_NATIVE)
        else:
            f.write(RUST_HEADER)

        for test in tests:
            f.write(generate_test_function(test, MODE))

    print(f"Generated {len(tests)} tests in {OUTPUT_FILE} (mode={MODE})")

RUST_HEADER = r"""/*
SPDX-License-Identifier: MPL-2.0
SPDX-FileCopyrightText: © 2023-2026 Bruce D'Arcus
*/

//! Auto-generated tests from CSL Test Suite
//! Do not edit manually. generated by tests/fixtures/update_disambiguation_tests.py

use csl_legacy::parser::parse_style;
use csln_core::{
    BibliographySpec, CitationSpec, Style, StyleInfo,
    options::Processing,
    citation::{Citation, CitationItem, CitationMode},
};
use csln_migrate::{
    analysis, Compressor, MacroInliner, OptionsExtractor,
    TemplateCompiler, Upsampler,
};
use csln_processor::{Processor, reference::Reference};
use csl_legacy::csl_json::Reference as LegacyReference;
use roxmltree::Document;
use std::collections::HashMap;

// --- Helper Functions copied/adapted from csln_migrate/src/main.rs ---

fn compile_style_from_xml(xml: &str) -> Style {
    let doc = Document::parse(xml).expect("Failed to parse XML");
    let legacy_style = parse_style(doc.root_element()).expect("Failed to parse legacy style");
    let options = OptionsExtractor::extract(&legacy_style);
    
    // We don't track provenance in tests usually, simplifying
    
    // --- Pipeline ---
    // 1. Deconstruction
    let inliner = MacroInliner::new(&legacy_style);
    
    let flattened_bib = inliner.inline_bibliography(&legacy_style).unwrap_or_default();
    let flattened_cit = inliner.inline_citation(&legacy_style);

    // 2. Semantic Upsampling
    let mut upsampler = Upsampler::new();

    upsampler.et_al_min = legacy_style.citation.et_al_min;
    upsampler.et_al_use_first = legacy_style.citation.et_al_use_first;
    let raw_cit = upsampler.upsample_nodes(&flattened_cit);

    if let Some(ref bib) = legacy_style.bibliography {
        upsampler.et_al_min = bib.et_al_min;
        upsampler.et_al_use_first = bib.et_al_use_first;
    }
    let raw_bib = upsampler.upsample_nodes(&flattened_bib);

    // 3. Compression
    let compressor = Compressor;
    let csln_bib = compressor.compress_nodes(raw_bib);
    let csln_cit = compressor.compress_nodes(raw_cit);

    // 4. Compilation
    let template_compiler = TemplateCompiler;
    let is_numeric = matches!(options.processing, Some(Processing::Numeric));
    
    let (mut new_bib, type_templates) = template_compiler.compile_bibliography_with_types(&csln_bib, is_numeric);
    let new_cit = template_compiler.compile_citation(&csln_cit);

    // Legacy fixups (simplified from main.rs)
     let author_suffix = if let Some(ref bib) = legacy_style.bibliography {
        analysis::bibliography::extract_author_suffix(&bib.layout)
    } else {
        None
    };
    analysis::bibliography::apply_author_suffix(&mut new_bib, author_suffix);

    let bib_and = analysis::bibliography::extract_bibliography_and(&legacy_style);
    analysis::bibliography::apply_bibliography_and(&mut new_bib, bib_and);

    // 5. Build Style
    let (wrap, prefix, suffix) = analysis::citation::infer_citation_wrapping(&legacy_style.citation.layout);

    Style {
        info: StyleInfo {
            title: Some(legacy_style.info.title.clone()),
            id: Some(legacy_style.info.id.clone()),
            default_locale: legacy_style.default_locale.clone(),
            ..Default::default()
        },
        templates: None,
        options: Some(options.clone()),
        citation: Some(CitationSpec {
            template: Some(new_cit),
            wrap,
            prefix,
            suffix,
            delimiter: analysis::citation::extract_citation_delimiter(
                &legacy_style.citation.layout,
                &legacy_style.macros,
            ),
            multi_cite_delimiter: legacy_style.citation.layout.delimiter.clone(),
            ..Default::default()
        }),
        bibliography: Some(BibliographySpec {
            template: Some(new_bib),
            type_templates: if type_templates.is_empty() { None } else { Some(type_templates) },
            ..Default::default()
        }),
        ..Default::default()
    }
}

fn run_test_case(csl: &str, input: &str, citation_items_json: &str, expected: &str, mode: &str) {
    let style = compile_style_from_xml(csl);
    
    // Parse Input Items
    let legacy_items: Vec<LegacyReference> = serde_json::from_str(input).expect("Failed to parse input items");
    let mut bibliography = indexmap::IndexMap::new();
    for item in legacy_items {
        bibliography.insert(item.id.clone(), Reference::from(item));
    }
    
    let processor = Processor::new(style, bibliography);
    
    // Debug: Check bibliography
    println!("Loaded {} bibliography items", processor.bibliography.len());
    // println!("Bibliography keys: {:?}", processor.bibliography.keys());

    if mode == "citation" {
        
        let citation_batches: Vec<Vec<HashMap<String, serde_json::Value>>> = 
            serde_json::from_str(citation_items_json).expect("Failed to parse citation items");
            
        let mut results = Vec::new();
        
        for batch in citation_batches {
            let items: Vec<CitationItem> = batch.into_iter().map(|obj| {
                CitationItem {
                    id: obj.get("id").unwrap().as_str().unwrap().to_string(),
                    ..Default::default()
                }
            }).collect();
            
            // Debug: Check citation items
            // println!("Processing citation items: {:?}", items.iter().map(|i| &i.id).collect::<Vec<_>>());
            
            let citation = Citation {
                items,
                mode: CitationMode::NonIntegral,
                ..Default::default()
            };
            
            let res = processor.process_citation(&citation).expect("Failed to process citation");
            results.push(res);
        }
        
        let actual = results.join("\n"); 
        println!("Expected: '{}'", expected);
        println!("Actual: '{}'", actual);
        assert_eq!(actual.trim(), expected.trim(), "Citation output mismatch");

    } else if mode == "bibliography" {
        // Need to register citations first?
        // Usually bibliography tests assume all items in INPUT are cited.
        // But some tests might specify CITATION-ITEMS to explicitly cite a subset.
        // If CITATION-ITEMS is present, we cite them first.
        
        if !citation_items_json.trim().is_empty() && citation_items_json != "[]" {
             let citation_batches: Vec<Vec<HashMap<String, serde_json::Value>>> = 
                serde_json::from_str(citation_items_json).unwrap_or_default();
             for batch in citation_batches {
                let items: Vec<CitationItem> = batch.into_iter().map(|obj| {
                    CitationItem {
                        id: obj.get("id").unwrap().as_str().unwrap().to_string(),
                        ..Default::default()
                    }
                }).collect();
                 let citation = Citation { items, ..Default::default() };
                 processor.process_citation(&citation).ok();
             }
        } else {
             // If no citations specified, cite everything?
             // Actually CSL test suite usually implies citing everything if testing bibliography unless specified.
             // But let's assume valid tests have citation-items if they need them.
        }

        let actual = processor.render_bibliography();
        // CSL test suite output for bibliography often contains HTML tags like <div class="csl-entry">...</div>
        // And usually double newlines.
        // We need to normalize whitespace/HTML for comparison, or assert containment.
        // For now, simple trim comparison.
        
        // Note: Our render_bibliography output might be plain text or contain Markdown/HTML depending on renderer.
        // Processor::render_bibliography() uses PlainText by default.
        // CSL test suite results often look like:
        // <div class="csl-bib-body">
        //   <div class="csl-entry">...</div>
        // </div>
        // If the expected result contains HTML, we might fail if we produce PlainText.
        // But many disambiguation tests just check the text content like "2000a" vs "2000b".
        
        // Let's check typical result format in our selected tests.
        // disambiguate_YearSuffixAndSort.txt -> "1990m!; 1990l!..." (It says MODE: citation, so it's citation output)
        
        assert_eq!(actual.trim(), expected.trim(), "Bibliography output mismatch");
    }
}
"""

def generate_test_function(test, gen_mode):
    # Use 4 hashes for raw string delimiter to be safe against embedded quotes
    if gen_mode == "processor":
        # Native mode: reference to pre-compiled Style instead of XML
        return f"""
#[test]
#[ignore]
fn test_{test['name']}_native() {{
    let input = r####"{test['input_items']}"####;
    let citation_items = r####"{test['citation_items']}"####;
    let expected = r####"{test['result']}"####;
    let mode = "{test['mode']}";

    run_test_case_native(input, citation_items, expected, mode);
}}
"""
    else:
        # Integration mode: XML-based (original)
        return f"""
#[test]
#[ignore]
fn test_{test['name']}() {{
    let csl = r####"{test['csl']}"####;
    let input = r####"{test['input_items']}"####;
    let citation_items = r####"{test['citation_items']}"####;
    let expected = r####"{test['result']}"####;
    let mode = "{test['mode']}";

    run_test_case(csl, input, citation_items, expected, mode);
}}
"""

RUST_HEADER_NATIVE = r"""/*
SPDX-License-Identifier: MPL-2.0
SPDX-FileCopyrightText: © 2023-2026 Bruce D'Arcus
*/

//! Auto-generated tests from CSL Test Suite - Native CSLN Mode
//! Do not edit manually. generated by tests/fixtures/update_disambiguation_tests.py --mode processor

use csln_core::{
    Style, StyleInfo,
    citation::{Citation, CitationItem, CitationMode},
};
use csln_processor::{Processor, reference::Reference};
use csl_legacy::csl_json::Reference as LegacyReference;
use std::collections::HashMap;

// --- Helper Functions for Native Mode ---

fn run_test_case_native(
    input: &str,
    citation_items_json: &str,
    expected: &str,
    mode: &str,
) {
    // Create a minimal test style
    // This demonstrates native CSLN structures without XML parsing
    let style = create_test_style();

    // Parse Input Items
    let legacy_items: Vec<LegacyReference> =
        serde_json::from_str(input).expect("Failed to parse input items");
    let mut bibliography = indexmap::IndexMap::new();
    for item in legacy_items {
        bibliography.insert(item.id.clone(), Reference::from(item));
    }

    let processor = Processor::new(style, bibliography);

    if mode == "citation" {
        let citation_batches: Vec<Vec<HashMap<String, serde_json::Value>>> =
            serde_json::from_str(citation_items_json)
                .expect("Failed to parse citation items");

        let mut results = Vec::new();

        for batch in citation_batches {
            let items: Vec<CitationItem> = batch
                .into_iter()
                .map(|obj| CitationItem {
                    id: obj.get("id").unwrap().as_str().unwrap().to_string(),
                    ..Default::default()
                })
                .collect();

            let citation = Citation {
                items,
                mode: CitationMode::NonIntegral,
                ..Default::default()
            };

            let res = processor
                .process_citation(&citation)
                .expect("Failed to process citation");
            results.push(res);
        }

        let actual = results.join("\n");
        println!("Expected: '{}'", expected);
        println!("Actual: '{}'", actual);
        assert_eq!(actual.trim(), expected.trim(), "Citation output mismatch");
    } else if mode == "bibliography" {
        if !citation_items_json.trim().is_empty() && citation_items_json != "[]" {
            let citation_batches: Vec<Vec<HashMap<String, serde_json::Value>>> =
                serde_json::from_str(citation_items_json).unwrap_or_default();
            for batch in citation_batches {
                let items: Vec<CitationItem> = batch
                    .into_iter()
                    .map(|obj| CitationItem {
                        id: obj.get("id").unwrap().as_str().unwrap().to_string(),
                        ..Default::default()
                    })
                    .collect();
                let citation = Citation {
                    items,
                    ..Default::default()
                };
                processor.process_citation(&citation).ok();
            }
        }

        let actual = processor.render_bibliography();
        assert_eq!(actual.trim(), expected.trim(), "Bibliography output mismatch");
    }
}

fn create_test_style() -> Style {
    // Minimal style structure for native testing
    // This will be populated per test with appropriate templates
    Style {
        info: StyleInfo {
            title: Some("Test Style".to_string()),
            id: Some("http://example.com/test".to_string()),
            ..Default::default()
        },
        ..Default::default()
    }
}
"""


if __name__ == "__main__":
    generate_rust_test_file()
