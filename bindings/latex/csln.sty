% csln.sty — CSLN LaTeX Package for LuaLaTeX
%
% Integrates the CSLN Rust citation processor into LuaLaTeX via LuaJIT FFI.
% No Biber, no .bbl file, no shell-escape required.
%
% Usage:
%   \usepackage[style=apa-7th, bibfile=refs]{csln}            % CSLN YAML bib
%   \usepackage[style=apa-7th, bibfile=refs.bib]{csln}        % biblatex .bib
%
% SPDX-License-Identifier: MPL-2.0
% SPDX-FileCopyrightText: © 2023–2026 Bruce D'Arcus

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{csln}[2026/02/21 v0.1.0-poc CSLN citation processor]

% Require LuaLaTeX
\RequirePackage{ifluatex}
\ifluatex\else
  \PackageError{csln}{csln requires LuaLaTeX}\relax
\fi

\RequirePackage{kvoptions}

% ---------------------------------------------------------------------------
% Package options
% ---------------------------------------------------------------------------
\SetupKeyvalOptions{family=csln,prefix=csln@}

% Path to a CSLN YAML style file (without extension, resolved via kpse, or
% an absolute path).  E.g. style=apa-7th  or  style=/full/path/to/my.yaml
\DeclareStringOption[apa-7th]{style}

% Path to the bibliography file.  Extension determines format:
%   .bib  → biblatex format   (uses csln_processor_new_from_bib)
%   other → CSLN YAML format  (uses csln_processor_new_from_yaml)
% Omit extension to default to CSLN YAML (.yaml).
\DeclareStringOption[refs]{bibfile}

\ProcessKeyvalOptions*

% ---------------------------------------------------------------------------
% Lua-side initialisation (runs once at \begin{document})
% ---------------------------------------------------------------------------
\directlua{
  local function find_csln_lua()
    local env = os.getenv("CSLN_LUA_PATH")
    if env and env ~= "" then return env end
    local sty_path = kpse.find_file("csln.sty", "tex") or ""
    local last_slash = sty_path:match("^(.*/)") or "./"
    local candidate = last_slash .. "csln.lua"
    local f = io.open(candidate, "r")
    if f then f:close(); return candidate end
    return nil
  end
  local csln_lua = find_csln_lua()
  if not csln_lua then
    error("csln.sty: cannot find csln.lua. "
      .. "Set CSLN_LUA_PATH or place csln.lua next to csln.sty.")
  end
  local ok, result = pcall(dofile, csln_lua)
  if not ok then
    error("csln.sty: failed to load csln.lua: " .. tostring(result)
      .. " (compile with: lualatex --shell-escape)")
  end
  csln_module = result
  if not csln_module then
    error("csln.sty: csln.lua returned nil. Check libcsln_processor is built.")
  end
}

\AtBeginDocument{%
  \directlua{
    local style_opt  = "\csln@style"
    local bibfile    = "\csln@bibfile"

    -- Resolve the style file: try as-is, then append .yaml, then kpse.
    local function resolve_style(s)
      local function try(p)
        local f = io.open(p, "r")
        if f then f:close(); return p end
        return nil
      end
      return try(s)
          or try(s .. ".yaml")
          or kpse.find_file(s,         "tex")
          or kpse.find_file(s..".yaml","tex")
          or s  -- last resort: pass through and let Rust error
    end

    local style_path = resolve_style(style_opt)

    -- Choose constructor based on file extension
    local is_bib = bibfile:match("%.bib$")
    local bib_path = bibfile
    if not is_bib then
      -- Try with / without .yaml extension
      local function try(p)
        local f = io.open(p, "r")
        if f then f:close(); return p end
        return nil
      end
      bib_path = try(bibfile)
             or  try(bibfile .. ".yaml")
             or  bibfile
    end

    if is_bib then
      csln_proc, err = csln_module.from_bib(style_path, bib_path)
    else
      csln_proc, err = csln_module.from_yaml(style_path, bib_path)
    end

    if not csln_proc then
      error("csln.sty: failed to initialise processor. "
        .. tostring(err)
        .. " | style=" .. tostring(style_path)
        .. " | bib="   .. tostring(bib_path))
    end
  }%
}

% parse_locator and do_cite are defined in csln.lua and accessible via csln_module.

% ---------------------------------------------------------------------------
% Citation commands
% ---------------------------------------------------------------------------

% \cite[locator]{key}  — style-driven (non-integral) citation
% Accepts an optional biblatex-style locator: \cite[p.~23]{key}
% NB: \cite is defined in the LaTeX kernel, so we must \renewcommand.
\renewcommand{\cite}[2][]{%
  \directlua{
    local raw_loc = "\luaescapestring{#1}"
    local label, locator = csln_module.parse_locator(raw_loc)
    local item = { id = "\luaescapestring{#2}" }
    if locator then item.label = label; item.locator = locator end
    csln_module.do_cite(csln_proc, { items = { item } })
  }%
}

% \cites[pre][suf]{k1}[pre][suf]{k2}...  — multi-item non-integral citation
% Use \citeitem{key} / \citeitem[loc]{key} inside \cites{...} for each item.
% Because TeX cannot loop over variable-length argument lists cleanly, we
% expose a two-step API matching biblatex's \cites syntax via a Lua accumulator.
\newcommand{\citestart}{%
  \directlua{ csln_cites_items = {} }%
}
\newcommand{\citeitem}[2][]{%
  \directlua{
    local raw_loc = "\luaescapestring{#1}"
    local label, locator = csln_module.parse_locator(raw_loc)
    local item = { id = "\luaescapestring{#2}" }
    if locator then item.label = label; item.locator = locator end
    table.insert(csln_cites_items, item)
  }%
}
\newcommand{\citeend}{%
  \directlua{
    csln_module.do_cite(csln_proc, { items = csln_cites_items })
  }%
}

% \cites convenience wrapper: \cites{k1}{k2}  (no per-item locators)
% For per-item locators use \citestart / \citeitem / \citeend.
\newcommand{\cites}[1]{%
  \citestart
  % #1 is treated as a comma-separated list of keys for the simple case
  \directlua{
    local keys = "\luaescapestring{#1}"
    for k in keys:gmatch("[^,]+") do
      k = k:match("^%s*(.-)%s*$")  -- trim whitespace
      table.insert(csln_cites_items, { id = k })
    end
  }%
  \citeend
}

% \textcite[locator]{key}  — integral (author in running text) citation
\newcommand{\textcite}[2][]{%
  \directlua{
    local raw_loc = "\luaescapestring{#1}"
    local label, locator = csln_module.parse_locator(raw_loc)
    local item = { id = "\luaescapestring{#2}" }
    if locator then item.label = label; item.locator = locator end
    csln_module.do_cite(csln_proc, { mode = "integral", items = { item } })
  }%
}

% \textcites{k1}{k2} — multi-key integral citation
\newcommand{\textcites}[1]{%
  \citestart
  \directlua{
    local keys = "\luaescapestring{#1}"
    for k in keys:gmatch("[^,]+") do
      k = k:match("^%s*(.-)%s*$")
      table.insert(csln_cites_items, { id = k })
    end
  }%
  \directlua{
    csln_module.do_cite(csln_proc, { mode = "integral", items = csln_cites_items })
  }%
}

% \addbibresource{file} — biblatex compat shim (overrides \bibfile option at runtime)
\newcommand{\addbibresource}[1]{%
  \directlua{
    -- re-initialise with the supplied bib file
    local bibfile = "\luaescapestring{#1}"
    local is_bib  = bibfile:match("%.bib$")
    local style   = "\csln@style"
    local stypath = kpse.find_file(style, "tex")
               or kpse.find_file(style .. ".yaml", "tex")
               or style
    if is_bib then
      csln_proc = csln_module.from_bib(stypath, bibfile)
    else
      csln_proc = csln_module.from_yaml(stypath, bibfile)
    end
  }%
}

% ---------------------------------------------------------------------------
% Bibliography
% ---------------------------------------------------------------------------

\newcommand{\printcslnbibliography}{%
  \directlua{
    if not csln_proc then
      tex.sprint("[csln: processor not initialised]")
    else
      local bbl = csln_proc:render_bibliography()
      if bbl then tex.sprint(bbl)
      else tex.sprint("[csln: bibliography render error]") end
    end
  }%
}

% Also provide \printbibliography as an alias for easier migration from biblatex.
% Use \providecommand so we don't clash if biblatex is already loaded.
\providecommand{\printbibliography}{\printcslnbibliography}

\endinput
