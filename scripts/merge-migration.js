#!/usr/bin/env node
/**
 * scripts/merge-migration.js
 *
 * Merges the output of csln-migrate (base.yaml) with the inferred templates
 * from infer-template.js (citation.json, bibliography.json).
 *
 * Usage:
 *   node scripts/merge-migration.js <style-name> <base-yaml> <citation-json> <bibliography-json>
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

// Parse arguments
const args = process.argv.slice(2);
if (args.length !== 4) {
    console.error('Usage: node scripts/merge-migration.js <style-name> <base-yaml> <citation-json> <bibliography-json>');
    process.exit(1);
}

const [styleName, basePath, citePath, bibPath] = args;
const outputPath = path.join(__dirname, '..', 'styles', `${styleName}.yaml`);

try {
    // 1. Load Base YAML (from csln-migrate)
    if (!fs.existsSync(basePath)) throw new Error(`Base YAML not found: ${basePath}`);
    const baseContent = fs.readFileSync(basePath, 'utf8');
    const baseData = yaml.load(baseContent);

    // 2. Load Inferred Templates (from infer-template.js)
    if (!fs.existsSync(citePath)) throw new Error(`Citation JSON not found: ${citePath}`);
    const citeData = JSON.parse(fs.readFileSync(citePath, 'utf8'));

    if (!fs.existsSync(bibPath)) throw new Error(`Bibliography JSON not found: ${bibPath}`);
    const bibData = JSON.parse(fs.readFileSync(bibPath, 'utf8'));

    // 3. Merge Data
    // Merge citation template
    if (citeData.citation && citeData.citation.template) {
        if (!baseData.citation) baseData.citation = {};
        baseData.citation.template = citeData.citation.template;

        // Merge other inferred citation properties if present and not in base
        // (e.g., wrap, delimiter)
        if (citeData.meta) {
            // Only if base doesn't have them or they are empty?
            // For now, let's trust the inferred ones for formatting properties if available
        }
    }

    // Merge bibliography template
    if (bibData.bibliography && bibData.bibliography.template) {
        if (!baseData.bibliography) baseData.bibliography = {};
        baseData.bibliography.template = bibData.bibliography.template;
    }

    // Add auto-generation comment header
    const comment = `# Generated by CSLN Migration Workflow
# Date: ${new Date().toISOString().split('T')[0]}
# Base Options: csln-migrate (Rust)
# Templates: infer-template.js (Output-Driven)
#
# REVIEW INSTRUCTIONS:
# 1. Verify 'options' block against requirements.
# 2. Check 'template' blocks against Oracle output.
# 3. Add any missing conditional logic or specific overrides.
#
`;

    // 4. Write Output
    // Use a custom schema or options if needed to preserve order/formatting preferences?
    // js-yaml doesn't preserve comments, so we prepend the header.
    // We want to keep key order close to standard if possible.

    // Custom dump to ensure top-level order
    const orderedData = {
        version: baseData.version || "",
        info: baseData.info || {},
        options: baseData.options || {},
        citation: baseData.citation || {},
        bibliography: baseData.bibliography || {}
    };

    const yamlStr = yaml.dump(orderedData, {
        lineWidth: 120,
        noRefs: true,
        quotingType: '"'
    });

    fs.writeFileSync(outputPath, comment + yamlStr);
    console.log(`Successfully merged migration data to: ${outputPath}`);

} catch (err) {
    console.error(`Error merging migration data: ${err.message}`);
    process.exit(1);
}
